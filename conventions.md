# Правила разработки (для code-ассистента)

Ключевые цели: простота (KISS), минимальные зависимости, маленькие и безопасные изменения. Все детали архитектуры, технологий и структуры — в `vision.md`. Здесь — только обязательные правила, влияющие на качество. Если правило конфликтует с вашим предложением — следуйте `vision.md` и предложите изменение отдельным шагом.

См. основной документ: `./vision.md`.

## Общие
- Не изменяй архитектуру и структуру вне рамок `vision.md`.
- Не добавляй новые библиотеки/сервисы без необходимости и явного обоснования.
- Не используй Docker. Python 3.11+, FastAPI, SQLAlchemy 2.0, Alembic, PostgreSQL — как в `vision.md`.
- Делаем маленькие коммиты/PR: одна задача — один PR, дифф как можно меньше.
- Следуй существующей структуре директорий `app/...`, `migrations/`, `tests/`.

## Стиль кода и типы
- Обязательно используй type hints во всём коде.
- Имена: функции/переменные — `snake_case`, классы — `PascalCase`, константы — `UPPER_SNAKE`.
- Pydantic v2: валидируй вход/выход API через схемы; не возвращай ORM-модели из обработчиков.
- Линт/формат: придерживайся `ruff` (pep8/pyflakes/isort) и запускай перед коммитом. Типы — `mypy` в умеренном режиме.

## API и схемы
- FastAPI-роуты типизированы, вход/выход — через Pydantic-схемы из `app/schemas/*`.
- Не смешивай слои: обработчики → сервисы → репозитории. Не обращайся к БД из обработчиков напрямую.
- Валидируй инпуты, устанавливай таймауты клиентов, не логируй чувствительные данные.

## БД и миграции
- Используй async SQLAlchemy 2.0. Один `AsyncSession` на запрос через зависимость FastAPI.
- Все изменения схемы — только через Alembic, одна миграция на изменение. Прошлые миграции не переписывай.
- Обновления данных делай идемпотентными (upsert по уникальным ключам). Лови и обрабатывай `UniqueViolation`.

Пример зависимости сессии
```python
# app/db/session.py
from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession
SessionLocal: async_sessionmaker[AsyncSession] = ...

# app/api/deps.py
from fastapi import Depends
async def get_session() -> AsyncSession:
    async with SessionLocal() as s:
        yield s
```

## Интеграции и кэш
- Birdeye: aiohttp-клиент с TTL-кэшем 15–60с (ключ: метод+URL+параметры), ретраи с backoff+jitter, глобальный Semaphore для параллелизма.
- PumpPortal WebSocket: автопереподключение, защита от дублей (идемпотентные записи), не падай при временных ошибках.
- Не ходи в сеть в юнит-тестах: абстрагируй клиента интерфейсом и подменяй фейком/моком.

Мини-шаблон ретраев
```python
for attempt in range(1, max_attempts + 1):
    try:
        return await client.fetch(...)
    except ClientError as e:
        if attempt == max_attempts: raise
        await asyncio.sleep(min(base * 2 ** (attempt-1), cap) + random.random()*jitter)
```

## Конкурентность
- Не блокируй event loop. Любой I/O — асинхронный.
- Ограничивай внешний параллелизм через один `asyncio.Semaphore` в слое сервисов.
- Периодические задачи — в `services/scheduler.py`; не плодить фоновые треды/процессы.

## Конфигурация
- Только через Pydantic Settings и переменные окружения. `.env` — для dev.
- Используй имена переменных из `vision.md` (например, `DB_DSN`, `BIRDEYE_API_KEY`, `BIRDEYE_CACHE_TTL`).
- Не хардкоди ключи/URL/пороги; то, что меняется — в `settings` (таблица) или env.

## Логирование
- Используй общий конфиг из `app/core/logging.py`.
- Логируй структурированно (JSON/ключ=значение), без секретов. Добавляй контекст: `token`, `request_id`, статус ответа внешних API.
- Ошибки интеграций — уровень WARN/ERROR с деталями (код, попытка, задержка до ретрая).

Пример логирования
```python
logger.info("birdeye.request", url=url, params=params, attempt=attempt)
logger.error("birdeye.failed", url=url, status=resp.status, err=str(e))
```

## Тесты
- Покрывай: расчёт скоринга, переходы статусов, граничные условия порогов, идемпотентность upsert.
- Минимизируй моки: мокай только внешние API/время. Тесты быстрые и детерминированные.
- Не тестируй то, что не менял, если не влияет на поведение текущей задачи.

## UI (минимум)
- Серверные шаблоны Jinja2 без тяжёлого фронтенда. CSS/JS — по мере реальной необходимости.
- В списке токенов — только необходимые колонки и простая пагинация/фильтры.

## Производительность и надёжность
- Избегай N+1 в БД; добавляй индексы, если нужны для запросов по частым фильтрам.
- Применяй кеш Birdeye и ограничение параллелизма. Не превышай лимиты API.
- Ошибки внешних сервисов не должны падать процесс: пропускай итерацию, логируй, пробуй снова.

## Когда нужна эскалация
- Любое добавление зависимости, изменение публичных API/схем, новая таблица/поле — предложи краткий план перед реализацией.
- Если правило из `vision.md` блокирует задачу — задай один уточняющий вопрос и предложи минимальную альтернативу.

Ссылки
- Архитектура, технологии, структура, модель данных: `./vision.md`
